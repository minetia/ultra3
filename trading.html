<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS FINAL</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        /* 기본 초기화 */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body { 
            background-color: #000; color: #fff; 
            font-family: -apple-system, sans-serif; 
            height: 100vh; width: 100vw; overflow: hidden; 
            display: flex; flex-direction: column; /* 세로 배치 고정 */
        }

        /* 1. 상단 헤더 (60px 고정) */
        header {
            height: 60px; width: 100%;
            background: #1a1a1a; 
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 15px; border-bottom: 1px solid #333;
            flex-shrink: 0; /* 크기 줄어들지 않음 */
        }
        .coin-title { font-size: 18px; font-weight: bold; }
        .price-box { text-align: right; }
        .price { font-size: 20px; font-weight: bold; color: #00ff9d; }

        /* 2. 차트 영역 (남은 공간 모두 차지) */
        #chart-area {
            flex-grow: 1; /* 남은 공간 꽉 채우기 */
            width: 100%;
            background-color: #151515; /* 차트 영역 확인용 색상 */
            position: relative;
        }

        /* 3. 하단 컨트롤러 (140px 고정) */
        .controls {
            height: 140px; width: 100%;
            background: #1a1a1a;
            padding: 10px;
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            border-top: 1px solid #333;
            flex-shrink: 0;
        }
        
        .pos-info { 
            grid-column: span 2; background: #222; 
            height: 35px; border-radius: 6px; 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 0 10px; font-size: 13px;
        }
        
        .btn { 
            height: 70px; border: none; border-radius: 8px; 
            font-size: 20px; font-weight: bold; color: #000; cursor: pointer; 
        }
        .btn-long { background: #00ff9d; }
        .btn-short { background: #ff3b30; color: #fff; }
    </style>
</head>
<body>

    <header>
        <div class="coin-title">BTC/USDT <span style="font-size:10px; color:#ff3b30; border:1px solid #ff3b30; padding:2px;">LIVE</span></div>
        <div class="price-box">
            <div id="price-txt" class="price">96,500.00</div>
            <div style="font-size:11px; color:#888">Asset: <span id="asset-txt">10,000</span></div>
        </div>
    </header>

    <div id="chart-area"></div>

    <div class="controls">
        <div class="pos-info">
            <span id="pos-txt">포지션: 없음</span>
            <span id="pnl-txt" style="font-weight:bold; color:#888;">PNL: 0.00%</span>
        </div>
        <button class="btn btn-long" onclick="bot.trade('LONG')">LONG</button>
        <button class="btn btn-short" onclick="bot.trade('SHORT')">SHORT</button>
    </div>

    <script>
        class MobileBot {
            constructor() {
                this.balance = 10000;
                this.position = null;
                this.price = 96500;
                this.chart = null;
                this.series = null;
                this.markers = [];
            }

            init() {
                // 1. 차트 컨테이너 찾기
                const container = document.getElementById('chart-area');
                
                // 2. 크기 직접 계산 (오류 방지)
                // 컨테이너의 실제 화면상 크기를 가져옴
                const rect = container.getBoundingClientRect();
                const width = rect.width || window.innerWidth;
                const height = rect.height || (window.innerHeight - 200); // 헤더+푸터 200px 제외

                // 3. 차트 생성
                this.chart = LightweightCharts.createChart(container, {
                    width: width,
                    height: height,
                    layout: { background: { color: '#151515' }, textColor: '#ccc' },
                    grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
                    timeScale: { 
                        timeVisible: true, 
                        secondsVisible: false,
                        rightOffset: 5,
                        borderColor: '#333'
                    },
                    rightPriceScale: { borderColor: '#333' },
                    crosshair: { mode: 1 },
                });

                this.series = this.chart.addCandlestickSeries({
                    upColor: '#00ff9d', downColor: '#ff3b30',
                    borderVisible: false, wickUpColor: '#00ff9d', wickDownColor: '#ff3b30'
                });

                // 4. 리사이즈 대응 (화면 회전 등)
                window.addEventListener('resize', () => {
                    const newRect = container.getBoundingClientRect();
                    this.chart.applyOptions({ 
                        width: newRect.width, 
                        height: newRect.height 
                    });
                });

                // 5. 데이터 생성 및 표시
                this.startData();
            }

            startData() {
                // 과거 100개 데이터 생성
                const data = [];
                let time = Math.floor(Date.now()/1000) - (100*60);
                let p = 96500;
                
                for(let i=0; i<100; i++) {
                    let move = (Math.random() - 0.5) * 60;
                    let close = p + move;
                    let open = p;
                    let high = Math.max(open, close) + Math.random()*20;
                    let low = Math.min(open, close) - Math.random()*20;
                    data.push({ time: time + i*60, open, high, low, close });
                    p = close;
                }
                
                this.series.setData(data);
                this.price = p;
                
                // [중요] 차트를 데이터에 딱 맞춤
                this.chart.timeScale().fitContent();
                
                // 실시간 움직임 시작
                setInterval(() => this.updateTick(), 1000);
            }

            updateTick() {
                // 가격 랜덤 변동
                const move = (Math.random() - 0.5) * 30;
                this.price += move;
                
                // 차트 업데이트 (마지막 봉 갱신 효과)
                const last = this.series.data()[this.series.data().length-1];
                const updated = {
                    time: last.time,
                    open: last.open,
                    high: Math.max(last.high, this.price),
                    low: Math.min(last.low, this.price),
                    close: this.price
                };
                this.series.update(updated);
                
                // UI 업데이트
                this.updateUI();
            }

            trade(side) {
                if(this.position && this.position.type !== side) {
                    this.close();
                    return;
                }
                if(this.position) return alert("이미 포지션이 있습니다.");
                
                this.position = { type: side, entry: this.price, size: (this.balance*0.98)/this.price };
                
                // 마커
                const time = this.series.data()[this.series.data().length-1].time;
                this.markers.push({ 
                    time, position: side==='LONG'?'belowBar':'aboveBar', 
                    color: side==='LONG'?'#00ff9d':'#ff3b30', 
                    shape: side==='LONG'?'arrowUp':'arrowDown', text: side 
                });
                this.series.setMarkers(this.markers);
                this.updateUI();
            }

            close() {
                if(!this.position) return;
                const diff = (this.price - this.position.entry) / this.position.entry;
                const pnl = this.position.type === 'LONG' ? diff : -diff;
                this.balance += (this.position.size * this.price * pnl);
                
                const time = this.series.data()[this.series.data().length-1].time;
                this.markers.push({ time, position: 'aboveBar', color: '#f0b90b', shape: 'circle', text: 'Close' });
                this.series.setMarkers(this.markers);
                
                this.position = null;
                this.updateUI();
            }

            updateUI() {
                const elPrice = document.getElementById('price-txt');
                elPrice.innerText = this.price.toLocaleString(undefined, {minimumFractionDigits: 2});
                
                if(this.position) {
                    const isWin = (this.position.type==='LONG' && this.price > this.position.entry) ||
                                  (this.position.type==='SHORT' && this.price < this.position.entry);
                    elPrice.style.color = isWin ? '#00ff9d' : '#ff3b30';
                } else {
                    elPrice.style.color = '#00ff9d';
                }
                
                document.getElementById('asset-txt').innerText = Math.floor(this.balance).toLocaleString();
                
                const elPnl = document.getElementById('pnl-txt');
                const elPos = document.getElementById('pos-txt');
                
                if(this.position) {
                    elPos.innerText = `포지션: ${this.position.type}`;
                    elPos.style.color = this.position.type==='LONG'?'#00ff9d':'#ff3b30';
                    
                    const diff = (this.price - this.position.entry) / this.position.entry;
                    const roe = (this.position.type==='LONG'?diff:-diff)*100;
                    elPnl.innerText = `PNL: ${roe.toFixed(2)}%`;
                    elPnl.style.color = roe >= 0 ? '#00ff9d' : '#ff3b30';
                } else {
                    elPos.innerText = "포지션: 없음";
                    elPos.style.color = "#fff";
                    elPnl.innerText = "PNL: 0.00%";
                    elPnl.style.color = "#888";
                }
            }
        }

        const bot = new MobileBot();
        // 화면이 다 그려진 후 0.1초 뒤에 실행 (안전장치)
        window.onload = () => setTimeout(() => bot.init(), 100);
    </script>
</body>
</html>
